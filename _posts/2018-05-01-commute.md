---
layout:     post
title:      "Analyzing commute with Google Location History and Python"
date:       2018-05-01 02:30:00
keywords:   python, google
image:      /assets/commute/map.png
---

![Map with commute](/assets/commute/map.png) 

Since I moved to Amsterdam I'm biking to work almost every morning. And as Google is
always tracking the location of my phone, I thought that it might be interesting to do
something with that data.

First of all, I've downloaded Location History data dump in json from
[Download your data page](https://takeout.google.com/settings/takeout). The format of the dump is very simple,
it's a dict with `locations` key that contains a lot of entries like this in descendant order by date:

~~~json
{
    "timestampMs" : "1525120611682",
    "latitudeE7" : 523508799,
    "longitudeE7" : 488938179,
    "accuracy" : 15,
    "altitude" : 49,
    "verticalAccuracy" : 2
}
~~~

It's very easy to parse it with Python:

~~~python
import json
from datetime import datetime
from collections import namedtuple

Point = namedtuple('Point', 'latitude, longitude, datetime')


def read_points():
    with open('data.json') as f:
        data = json.load(f)

    for point in data['locations']:
        yield Point(
            point['latitudeE7'] / 10 ** 7,
            point['longitudeE7'] / 10 ** 7,
            datetime.fromtimestamp(int(point['timestampMs']) / 1000)
        )
        
points = read_points()
~~~
~~~python
>>> [*points]
[Point(latitude=52.350879, longitude=4.893817, datetime=datetime.datetime(2018, 4, 30, 22, 36, 51, 682000)), ...]
~~~

As I moved to my current place in November, it's safe to ignore all entries before:

~~~python
from itertools import takewhile

from_date = datetime(2017, 11, 1)

after_move = takewhile(lambda point: point.datetime >= from_date, points)
~~~

And weekends:

~~~python
work_days = (point for point in after_move
             if point.datetime.weekday() < 5)
~~~

Usually, I'm heading to work between 9 am and 10 am, but as the Netherlands are switching between
summer and winter timezones, it will be safer to treat everything between 7 am and 9a m as possible commute time:

~~~python
from_hour = 7
to_hour = 12

commute_time = (point for point in work_days
                if from_hour <= point.datetime.hour < to_hour)
~~~

Then I grouped everything by date:

~~~python
from itertools import groupby

by_days = groupby(commute_time, key=lambda point: point.datetime.date())
~~~
~~~python
>>> [(day, [*vals]) for day, vals in by_days]
[(datetime.date(2018, 4, 27),
 [Point(latitude=52.350879, longitude=4.893817, datetime=datetime.datetime(2018, 4, 27, 11, 58, 17, 189000)), ...]),
 ...]
~~~

After that, I selected the last point at home and the first point at work for every day. A point considered home or work
if it's distance from home or work is smaller than 50 meters. The distance can be easily calculated with [geopy](https://github.com/geopy/geopy):

~~~python
from geopy.distance import geodesic

home = (52.350879, 4.893817)  # not really =)
work = (52.3657573, 4.8980648)

max_distance = 0.050

def last_at_home(points):
    result = None
    for point in points:
        if geodesic(home, point[:2]).km <= max_distance:
            result = point
    return result


def first_at_work(points, after):
    for point in points:
        if point.datetime > after.datetime and geodesic(work, point[:2]).km <= max_distance:
            return point


Commute = namedtuple('Commute', 'day, start, end, took')


def get_commute():
    for day, points in by_days:
        points = [*points][::-1]

        start = last_at_home(points)
        if start is None:
            continue

        end = first_at_work(points, start)
        if end is None:
            continue

        yield Commute(
            day, start.datetime, end.datetime, end.datetime - start.datetime,
        )


commutes = [*get_commute()][::-1]
~~~
~~~python
>>> commutes
[Commute(day=datetime.date(2017, 11, 2), start=datetime.datetime(2017, 11, 2, 9, 39, 13, 219000), end=datetime.datetime(2017, 11, 2, 9, 52, 53, 295000), took=datetime.timedelta(0, 820, 76000)), ...]
~~~

Now it's easy to plot a graph of daily commute with [matplotlib](https://matplotlib.org/):

~~~python
from matplotlib import pyplot

fig, ax = pyplot.subplots()
ax.plot([commute.day for commute in commutes],
        [commute.took.total_seconds() / 60 for commute in commutes])

ax.set(xlabel='day', ylabel='commute (minutes)',
       title='Daily commute')
ax.grid()
pyplot.show()
~~~

It's easy to spot days when I had appointments in the morning:

![Daily commute](/assets/commute/line.png) 

Then I thought that it might be interesting to compare average monthly
commute with [the weather](https://en.wikipedia.org/wiki/Amsterdam#Climate):

~~~python
from statistics import median, mean

weather = [3.4, 3.5, 6.1, 9.1, 12.9, 15.4, 17.6, 17.5, 14.7, 11.0, 7.1, 4.0, 10.19]


def get_monthly(month, vals):
    vals = [*vals]
    return (
        month,
        mean(commute.took.total_seconds() / 60 for commute in vals),
        weather[vals[0].day.month - 1]
    )


monthly = [get_monthly(month, vals)
           for month, vals in groupby(commutes, lambda commute: commute.day.strftime('%Y-%m'))]
fig, ax = pyplot.subplots()
indexes = np.arange(len(monthly))
ax.scatter(indexes, [avg[1] for avg in monthly],
           label='Commute')
ax.scatter(indexes, [avg[2] for avg in monthly],
           label='Weather')
ax.set_xticks(indexes)
ax.set_xticklabels([avg[0] for avg in monthly])
ax.set(xlabel='month', title='Commute and weather')
ax.legend()
pyplot.show()
~~~

And there's actually some correlation:

![Mean commute and wether](/assets/commute/mean.png)

But only with mean values, with median values it's almost the same for every month:

![Median commute and wether](/assets/commute/median.png)

[Gist with sources.](https://gist.github.com/nvbn/be3c4e470824eee54adc54404dbbc362)
